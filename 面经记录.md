## 快手

### 面经1

1. `typeof Object`、`typeof {}`、`typeof []`返回什么

   `Object`是构造函数，返回'function'，后两个都是'object'

2. 实现lodash的set方法？

   可以递归也可以用迭代，这里用迭代

   ```javascript
   function mySet(obj, path, value) {
     const arr = path.split(".");
     let curObj = obj;
     arr.forEach((e, idx) => {
       if (idx === arr.length - 1) {
         curObj[e] = value;
       }
       
       if (!curObj.hasOwnProperty(e)) {
         curObj[e] = {};
       }
       curObj = curObj[e];
     });
   }
   ```
   
3. 实现lodash的get方法？

   ```javascript
   function myGet(obj, path, defaultValue) {
     const pathArr = path.split(".");
     let curObj = obj;
     let res = defaultValue;
     for (let i = 0; i < pathArr.length; i++) {
       if (curObj.hasOwnProperty(pathArr[i])) {
         curObj = curObj[pathArr[i]];
       } else {
         res = defaultValue;
         break;
       }
     }
     return res;
   }
   ```

4. 如果catch后面还有then的话，这个then还执行吗？

   因为catch会返回Promise，所以后面的then依然会执行s

5. 实现promisefy

   ```javascript
   // 正常使用
   fs.readFile('./a', function () {/*...*/});
   // 使用promise包装后
   const promisefy = (fn) => {
     // ...
   }
   // 使用
   
   promisefy('./a').then().catch()
   ```

6. cookie有哪些字段，http-only什么意思...？

   - name，cookie的名称
   - value，cookie的值
   - domain，可以访问该cookie的域名
   - path，可以访问此cookie的页面路径
   - expires/max-age，此cookie的过期时间
   - size，此cookie的大小
   - http-only，不能通过document.cookie来访问此cookie
   - secure，是否只能通过https来传递此条cookie

7. cookie的作用？

   - 保存用户状态
   - 跟踪用户行为
   - 定制页面

8. mounted，onload，domcontentloaded顺序？

   mounted、domcontentloaded、onload




## 字节

### 面经1

1. 实现`JSON.stringify()`，考虑undefined、function、symbol，有循环引用就报错。

2. 二维数组环形遍历。

3. 驼峰化字符串

4. 懒加载原理，分清window.pageYOffest、ele.offsetTop、window.innerHeight。

5. 柯里化，`sum(1)(2).value()`和`sum(1, 2).value()`结果都返回3。

   ```javascript
   function sum(a, b, c, d) {
     return a + b + c + d;
   }
   
   function curry(fn, ...args) {
     if (args.length >= fn.length) {
       return {
         value() {
           return fn.apply(this, args);
         },
       };
     }
     return function (...params) {
       return curry.call(this, fn, ...args.concat(params));
     };
   }
   
   console.log(curry(sum, 1, 2, 3, 4).value());
   console.log(curry(sum, 1, 2)(3, 4).value());
   ```

### 面经2

1. 水平垂直居中

1. bind实现

1. DOM转JSON对象（[答案](./前端算法.md#DOM转JSON对象)）、JSON对象转DOM（[答案]()）

1. 排序算法

1. Vue组件通信的方法（7 + 1 种）

1. 禁止浏览器缓存的方法

   - `Cache-Control: no-cache, no-store, must-revalidate`
   - `Expired: 0`
   - 如果是http1.0，header是`progma: no-cache`
   - 谷歌浏览器`Network Conditions`里有一个`disable cache`

1. Vue父组件调用子组件的方法

   在子组件用expose选项暴露出方法，父组件用ref来调用它

1. 类数组转换成标准数组的方法，[答案](./js.md#将类数组转换为数组的方法)

1. css3的新特性有哪些？

   - 选择器有新增的，比如`p:nth-child(2)`表示特定父元素下的第2个p元素
   - 边框，box-shadow、border-radius等
   - 边框，background-clip、background-origin
   - transform、transition、animation
   - rgba、hsla

1. localStorage和sessionStorage存在哪里？

   它们都在window上，并且localStorage有同源限制，sessionStorage不仅有同源限制，而且只在当前浏览器tab访问，cookie是4k，localStorage和sessionStorage能到5M。

1. js的this指向

      - 严格模式下，如果function在全局调用，内部的this为undefined，非严格模式下为window
      - this取决于函数如何调用，如果是箭头函数，则里面的this会在箭头函数被声明时就定好，指向创建时的词法环境

1. Vue各生命周期都做了什么事情？

      - beforeCreate，此钩子之后，执行initState，对data、methods等选项初始化
      - created，data、methods等选项都已初始化完成
      - beforeMount，编译模板，调用render生成vnode，此时还未生成真实DOM
      - mounted，挂载完成，真实DOM都已经生成
      - beforeUpdate，数据更新之后、DOM变化之前
      - updated，DOM已完成
      - actived，被keep-alive激活
      - deactived，被keep-alive缓存
      - beforeUnmount，销毁前
      - unmounted，销毁后

1. new Vue()发生了什么？

      构造函数内是调用`_init()`来完成全部初始化工作的，包括：

      初始化生命周期、初始化event事件中心、初始化render、调beforeCreate钩子、初始化injection、初始化state（data、methods等）、初始化provide、调created钩子，如果有el，就执行$mount，开始挂载

1. 发布订阅的详细过程？

      可以讲一讲Proxy的get和set、track和trigger的过程，WeakMap、Map、副作用函数就

### 面经3

1. 函数节流

2. cookie、localStorage、sessionStorage区别？

   4K、5M，永久存储和会话存储，有同源限制，cookie每次请求都带上

3. new操作做了什么？

   创建对象、指向prototype、对象赋值给构造函数的this、执行构造函数、若不返回对象，则拿到创建的对象。

4. 实现链式调用？

   方法都在一个对象中，每个方法执行完都返this。

5. 合并两个有序数组

6. 和为targe的二叉树路径，根到叶

7. html5新增的标签

   canvas、audio、video、article、header、footer、nav等

8. css垂直居中

   flex、grid、positon+transform、flex+margin: auto

9. vue计算属性怎么实现的

   vue的计算属性和发布订阅过程很像，每一个vue计算属性都会创建副作用函数，如果其依赖的状态发生变化，那么该状态就会触发全部的副作用函数执行，而计算属性的副作用函数只会更新dirty为true，下次访问该计算属性时，先查dirty如果为true，就执行get，并把结果放进缓存，改dirty为false。

   所以，发布订阅者模式中的副作用函数，我认为就是在改虚拟dom，最后再用diff对比出差异进而改真实dom。

10. vue双向绑定实现原理？

    就是数据绑定+事件回调，有语法糖v-model，数据绑定实际上就是发布订阅模式。

11. 清除浮动的方法？

    先看看浮动造成的效果，红框是浮动的，蓝框不会包含它，造成它覆盖了正常的文档流。

    这里是蓝色文本在float元素之前，如果float元素在蓝色文本之前，就更好办了，直接让蓝色文本`clear: left`

    <img src="/Users/erfan/Library/Application Support/typora-user-images/截屏2023-05-21 18.31.43.png" alt="截屏2023-05-21 18.31.43" style="zoom: 33%;" />

    - 用伪元素+`clear: both`，在蓝框内添加一个块级伪元素

      ```css
      蓝框::after {
        content: '';
        display: block;
        clear: both	// 该伪元素的左右都不能有float元素
      }
      ```

    - 让蓝框变成BFC，就会包含float元素

      ```css
      蓝框 {
      	overflow: hidden;
      }
      ```

12. 能不能用ajax封装一个axios？

    当然可以，注意请求拦截和响应拦截

### 面经4

1. 说说各种协议，想到什么说什么，[这里](./network.md#各层有哪些协议)
2. 三次握手
3. 四次挥手
4. http缓存
5. 给代码输出结果，更多的练习放在[这里](./输出试题.md)

### 面经5

1. css中position有哪些值？

   static（正常文档流）、relative、absolute、fixed（相对视口）、sticky（相对于最近的滚动祖先定位）

2. http和https的区别

   - 明文、加密，安全、不安全
   - 是否要证书
   - 有无TLS协商，默认端口不一样

3. 对称加密和非对称加密的区别

   对称加密使用相同密钥加解密，非对称加密使用不同的密钥加解密

4. setTimeout和Promise的区别

   setTimeout由定时器控制回调，Promise只有等到fulfilled之后才执行回调

5. 实现一定时间内事件只出触发一次（节流）

### 面经6

1. 输入url到网页显示的过程？

   DNS解析，TCP三次握手，TLS协商，发送http请求，解析html文档，预加载扫描器，构建DOM树，构建CSSOM树，组成渲染树，布局，绘制。

2. 两个链表的第一个公共节点

   直接算出两个链表的长度

3. 前端控制并发请求数，比如20个异步请求，最大并发3个；实现`concurrencyRequest(urls, maxNum)`，要求返回全部的相应结果数组。答案在[这里]()

4. 下面输出什么？输出1，因为foo函数创建的时候会保留全局词法环境的地址，当它被执行的时候，foo的词法环境就会指向全局词法环境，取到的value也就是1。这种题，就看函数是在哪里创建的。

   ```javascript
   var value = 1;
   function foo() {
     console.log(value);
   }
   function bar() {
     var value = 2;
     foo();
   }
   bar();
   ```


### 面经7

1. 自定义数据属性是什么?

   它支持为html元素赋予自定义属性的能力，data-name、data-age，名字自己定。

   用js可以访问，用htmlElement.dataset即可，也可以用css访问，用`attr(data-name)`

2. title的作用

   - 作为title元素，它是网页的标题
   - 作为元素的属性，它是一种提示，鼠标浮上元素后即可展示title的值

3. 列表循环

4. defer和async 的区别，答案在[这里](./js.md#带async和defer的script标签)

   简单讲，defer和async都不阻塞，但defer会保证在DOM树构建完后再执行，async加载完就执行，且defer保证多个script的顺序，async不保证。

5. DOMContenLoaded和window.onload的区别

   当整个页面，包括样式、图片和其他资源被加载完成时，会触发 `window` 对象上的 `load` 事件

   当DOM树构建完成后，会触发DOMContenLoaded

6. 什么是盒模型？

   html元素在浏览器上都是一个盒子，分content、padding、border、margin

7. 宽度不定，让三个元素按1:1:1布局

   容器flex，子元素flex: 1（实际是flex: 1 1 0）

8. 介绍BFC

   产生BFC的条件有html元素、overflow设置hidden、flex元素的子元素（子元素非flex、grid）；

   BFC的特性：会包含float元素、不会被float元素遮盖、会有margin合并

9. DOM事件流的顺序

   捕获阶段从document到目标元素，冒泡阶段从目标元素到document

10. 什么是事件委托

    如果所有元素都有相同的处理程序，就不需要为每一个元素都添加这个处理函数，而是把处理函数放在公共父元素上，利用event.target可以确定哪个是目标元素。

### 面经8

1. 盒模型有哪些类型？

   box-sizing的两个取值，border-box和content-box

2. js类型有哪些

   默写一遍7 + 1：string, number, boolean, undefined, null, bigInt, symbol, object

3. `[] instanceof Object`的结果是什么？为什么？

   true，`[]`指向`Array.prototype`，`Array.prototype`指向`Object.prototype`。`Array.prototype.__proto__ === Object.prototype`是`true`

4. 手写bind。再默写一次

   ```javascript
   Function.prototype.myBind = function (context, ...args) {
     if (Function.prototype === this) {
   		throw new Error('err');
     }
     const fnKey = Symbol('fn');
     const fn = this;
     context[fnKey] = fn;
     
     return function F(...params) {
       if (this instanceof F) {
         return new fn(...args.concat(params));
       } else {
         return context[fnKey](...args.concat(params));
       }
     }
   }
   ```

5. 如何启动事件冒泡？

   事件都有捕获和冒泡，`addEventListener()`第三个参数默认false表示在冒泡阶段触发处理函数，true表示在捕获阶段触发处理程序。

6. 如何启动事件委托？

   把处理函数放在公共元素上，然后启动冒泡或捕获

7. 斐波那契数列

8. lc70爬楼梯，要求空间`O(1)`

9. lc92反转链表，m到n

10. 从上到下打印二叉树，[题目](https://leetcode.cn/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/)，就是一个简单的层序遍历

### 面经9

1. Vue-router基本用法

   配路由routes、创建router，植入到Vue中，hash模式和history模式

2. 在Vue实例如何访问router实例

   用this.$router

3. 手写JSONP

   此处再默写一遍，这样返回的脚本是fn调用，传参是这个path应该返回的data

   ```javascript
   function fn(obj) {
     console.log(obj);
   }
   
   function jsonp() {
     const url = 'http://localhost:8080/jsonp?func=fn';
     const script = document.createElement('script');
     script.setAttribute('type', 'text/javascript');
     script.setAttribute('src', url);
     document.body.append(script);
   }
   ```

4. 手写继承，`inherit(A, B)`

   ```javascript
   // A 和 B都是构造函数, B继承A
   B.prototype = new A();
   B.prototype.constructor = B;
   
   // A 和 B都是
   ```

5. 给Number加一个方法，保留小数点后n位数

   ```javascript
   Number.prototype.xxxFunc = (n) => {
   	const str = this + '';
     let i = 0;
     let count = 0;
     let res = '';
     while (str.charAt(i) !== '.') {
       res += str.charAt(i);
       i++;
     }
     for (let i = 0; i < n; i++) {
   		if (str.charAt(i) === undefined) {
         res += '0';
       } else {
         res += s.charAt(i);
       }
     }
     return Number(res);
   }
   ```

6. 三数之和

   先排序，再搭两个for的框架

### 面经10

1. http1/2/3，讲讲区别，各个版本有什么特征？

   http1有很多缺点，字节流传输导致请求只能一个一个发送、header太多且太大、明文传输、TCP本身的性能问题、不能服务器推送；因此http2就有了改进，它用二进制传输、header压缩、维护header表、支持服务器推送、TCP多路复用，一个TCP连接可以同时发多个http请求；但由于http2也基于TCP，TCP队头阻塞后问题比http1还大，因此http3就用了QUIC协议，基于UDP，不需要再三次握手。

2. http/2的TCP多路复用？

   在应用层就对http报文二进制分帧，因此一个TCP连接就可以同时传多个请求，不需要保证http按顺序接收，哪个请求先接收完毕就先响应哪个。

3. 网络攻击知道哪些？

   xss，利用钓鱼网站访问主站，拼上恶意的参数，进行脚本注入，由于带上了用户的cookie，导致恶意脚本执行

   csrf，服务器无法判断发送请求的是不是自己的网站，钓鱼网站利用用户cookie向服务器请求，执行恶意操作。

4. 浏览器缓存

   强缓存

   协商缓存

5. 实现LRU

6. margin和padding的区别

7. 水平垂直居中

   flex、grid、position、flex + `margin: auto`

8. 事件冒泡、委托

### 面经11

1. 排序算法

   ```javascript
   function quickSort(nums, low, high) {
     if (low >= high) {
       return;
     }
     const mid = partition(nums, low, high);
     quickSort(nums, low, mid - 1);
     quickSort(nums, mid + 1, high);
   }
   
   function partition(nums, low, high) {
     const pivot = nums[low];
     while (low < high) {
       while (low < high && nums[high] >= pivot) {
         high--;
       }
       nums[low] = nums[high];
       while (low < high && nums[low] < pivot) {
         low++;
       }
       nums[high] = low;
     }
     nums[low] = pivot;
     return low;
   }
   
   const nums = [3, 5, 2, 5, 2, 5, 1, 7, 5, 4, 2, 9, 0, 7];
   quickSort(nums, 0, nums.length - 1);
   console.log(nums);
   ```

2. 常见的数据结构有哪些？

   线性表（数组、链表）、树、栈、队列、堆、图、散列表

3. 网络攻击

   xss（诱导用户点击拼接了恶意参数的url，发送请求，带上cookie，植入恶意脚本）、csrf（服务器无法判断发请求的是自己的网站还是其他网站，解决的话用Origin、Referer或者token都可以）。

4. TCP和UDP的区别

   可靠性、是否面向连接、传输是字符流还是数据报、是否有拥塞控制、流量控制、数据分片不一样，一个是大于MTU，一个是大于MSS就才在网络层分片。

5. 闭包

   js的函数是天然的闭包，函数被创建时，就记录下其创建时的词法环境，当它被执行的时候，除了创建自己的词法环境，还会指向记录的上层词法环境，因此，这个函数自己的词法环境+上层词法环境，就构成了一个闭包。

6. 用function实现类，[这里](./面试记录.md#用function实现class)

7. 堆排序

   ```javascript
   function buildHeap(nums) {
     const len = nums.length;
     for (let i = Math.floor(len / 2); i >= 0; i--) {
       heapAdjust(nums, i, len);
     }
   }
   
   function heapAdjust(nums, i, len) {
     let child = 2 * i + 1;
     while (child < len) {
       if (child + 1 < len && nums[child] < nums[child + 1]) {
         child = child + 1;
       }
       if (nums[i] < nums[child]) {
         let temp = nums[i];
         nums[i] = nums[child];
         nums[child] = temp;
         i = child;
         child = 2 * child + 1;
       } else {
         break;
       }
     }
   }
   
   function heapSort(nums) {
     buildHeap(nums);
     let len = nums.length;
     for (let i = len - 1; i > 0; i--) {
       const temp = nums[0];
       nums[0] = nums[i];
       nums[i] = temp;
       len--;
       heapAdjust(nums, 0, len);
     }
   }
   ```

   

8. 最大子序列和，分连续和不连续，动态规划

9. 64匹马8条赛道比出前4名，最少需要比多少场？

   64进32进16再进10，去掉第一名，再进9，再假设去掉一个，8个比一次

10. 拿苹果问题

11. lc84

### 面经12

1. Vue3是怎么提升性能、优化的？

   - diff算法优化，利用patchFlag标记出来动态的vnode，对于静态的，patch的时候就不用diff了；
   - 对于不参与更新的静态元素，只会创建一次vnode，每次都用它；
   - 事件监听缓存，就不用把它视为动态绑定去监听它的变化，不用和响应式状态一样；
   - ssr优化
   - 利用Tree-Shaking，摇掉没有用到的computed、ref等
   - 改defineProperty为Proxy

2. Vue3的组合式API相对于选项式API有什么优点？

   当一个组件特别庞大的时候，如果用选项式，那么属于同一逻辑的代码就会被拆到各个地方，而组合式API可以被相同逻辑的代码聚在一起，便于维护。如果是小型组件，选项式API还是值得采用的。

3. Vue3的Tree-Shaking大概是怎么做的？

   利用ES6的import和export，在编译阶段就确定模块依赖关系，找出未使用的代码。

4. 手写Array.flat，绑到原型上，并添加层级控制

   浅写一个递归版和reduce版

   ```javascript
   const res = [];
   Array.prototype.myFlat = function () {
     if (Array.prototype === this) {
       throw new Error("err");
     }
     for (let e of this) {
       if (Array.isArray(e)) {
         e.myFlat();
       } else {
         res.push(e);
       }
     }
   };
   // reduce版
   Array.prototype.myFlat = function () {
     if (this === Array.prototype) {
       throw new Error("err");
     }
     return this.reduce((pre, cur) => {
       return Array.isArray(cur) ? pre.concat(cur.myFlat()) : pre.concat(cur);
     }, []);
   };
   
   console.log([1, 2, [3, 4, [5, 6]]].myFlat());
   
   ```

5. loader、plugin的区别？

6. 判断数组

   - `Array.isArray()`
   - `Object.prototype.toString.call(arr)`
   - `arr instanceof Array`

7. `instanceof`原理

   变量从一个对象的proto开始，终点是构造函数的prototype，用proto一直往上推，`Object.getPrototypeOf()`，看原型链上是否能找到。

8. 如何判断属性是自己的还是原型链上的？

   - `obj.hasOwnProperty(key)`
   - `Reflect.has(obj, key)`

9. ES6模块和CommonJS的区别？

   简写：

   - c引入的是副本对象，e是动态映射
   - c建立模块依赖关系是在运行时，e是在编译阶段
   - c的引入语法可以放在if中，e不能
   - e可以在编译时丢掉死代码，还可以直接导入导出变量，不用层层引用，因此程序效率高
   - c没办法解决循环引用，e可以
   - c可以对引入的对象做更改，因为是副本，但e不行

10. Vue为什么需要key？

    最大程度复用DOM

    对于列表，Vue使用原地更新，如果re-render后能在旧vnode中找到key，那就可以拿来直接patch补丁，而不需要销毁或重建DOM。

11. 组件间通信方式？

    7 + 1种，简单默写：props、emit、provide/inject、expose/ref、v-model、attrs、vuex、mitt

12. for循环+setTimeout输出题

    ```javascript
    // 5 5 5 5 5
    for (var i = 0; i < 5; i++) {
      setTimeout(() => {
        console.log(i);
      }, i * 1000);
    }
    
    // 0 1 2 3 4
    for (let i = 0; i < 5; i++) {
      setTimeout(() => {
        console.log(i);
      }, i * 1000);
    }
    
    
    ```

13. 数组拍平

    浅写一次：

    ```javascript
    Array.prototype.myFlat = function () {
      return this.reduce((pre, cur) => {
        return Array.isArray(cur) ? pre.concat(cur.myFlat()) : pre.concat(cur);
      }, []);
    };
    ```

14. 和最大的最长子数组（未解）

### 面经13

1. https如何实现加密？

   TLS协商出一对称密钥，用非对称加密保护对称加密

2. 数字证书中包含哪些内容？

   序列号（唯一）、公钥、所有者名称、证书生效的起止日期、签名算法、签名哈希算法

3. http2头部压缩怎么实现？

   gzip或compress压缩，另外两端还会维护一张header表，传输的时候直接用索引即可

4. http2多路复用原理？

   http2采用二进制传输，在应用层就进行二进制分片，每个分片都有编号，即使顺序打乱也无所谓，因此一个TCP连接就可以同时发送多个请求，接收端TCP会不断向应用层交付数据，应用层再进行拼接，拼完一个请求后就可以立刻响应，并没有响应的先后顺序。

5. TCP拥塞控制

   首先是有拥塞窗口

   慢启动（指数增长）、拥塞避免（线性增长）、拥塞发生就会出现超时重传（拥塞窗口急剧减小）和接收端丢包后立刻发三个ACK触发快速重传（缓和减小）、快速恢复（快速重传后就是快速恢复）。

6. 跨域方案、xss、csrf及防御手段

7. 常用plugins

   HtmlWebpackPlugin、DefinePlugin、mini-css-extract-plugin（提取css到单独文件中）

8. requestAnimationFrame是怎么保证不卡顿的？

   setTimeout和setInterval都需要传时间，但是这个时间需要开发人员定，开发人员很难确定好这个时间到底设置多少，而且当任务队列较长时，还并不能保证按时执行

   requestAnimationFrame就不需要开发者确定时间，它完全依据浏览器的重绘频率，确保回调在两次重绘之间执行一次。这个接口能卡准时间什么时候执行回调，不多不少，一帧就执行一次。

9. translate3d

   x、y、z三个坐标轴上都偏移

10. 平衡二叉树（判断）

### 面经14

1. `[] == []`和`[] == ![]`的结果

   隐式转换只出现在引用类型和基本类型比较

   引用类型和基本类型比较的时候，会先调valueOf或toString转换成基本类型后，再比较

   `[] == []`这是两个引用类型比较，不存在隐式转换，结果为false

   `[] == ![]`，加了!变成false，`[]`和false比较，`[]`会调toString变成空字符串，因此返回true

2. new操作符原理

   创建空对象，指向构造函数的prototype，把this指向这个对象，执行构造函数，构造函数若返回其他对象，则取其他，否则就返回这个新创建的对象

3. 盒模型有哪些？

   box-sizing的两个值，border-box和content-box

4. `display: none`、`visibility: hidden`、`opacity: 0`的区别

   **结构：**

   display: none会让元素从渲染树消失，渲染时不占据空间；不可点击；

   visibility: hidden不会让元素从渲染树中消失，渲染元素占据空间，只是内容不可见，有点像看不见也摸不着；不可点击；

   opacity: 0不会让元素从渲染树消失，渲染元素继续占据空间，只是内容不可见，有点像看不见但摸得着；可点击

   **继承：**

   display: none不能被继承；

   visibility是继承属性，子孙结点消失是因为继承了它，通过给子元素设置visibility: visible可重新显示子元素。

   opacity: 0会被继承（实际上父元素和子元素被当成整体），但一般是不能在Chrome开发工具看到的，opacity会把这个元素及其后代当成整体，它们拥有相同的不透明度，后代把opacity设置成1也不能取消隐藏。

   **性能：**

   display: none的切换会造成文档回流（也叫重排， reflow），性能消耗大，毕竟要重新计算元素的位置形状；

   visibility: hidden，修改元素造成本元素的重绘（repaint），性能消耗少；

   opacity: 0，提升为合成层，是重建图层，不和动画属性一起（加了过渡效果transition）则不会产生repaint，其他情况会导致重绘，性能消耗少。

   **适用场景：**

   display: none，可以用于显示出原来不存在的元素，比如一个弹窗。

   visibility: hidden，用于隐藏和显示一个元素，并且需求是不能影响其他元素的布局/位置。

   opacity: 0，搭配transition使用，可以实现透明度的一个过渡。

   总结是，如果只是想隐藏元素，并且没有过渡效果，还不能影响其它元素的布局，那么，选opacity: 0。

5. 状态码301、302、304

   301永久重定向，访问的资源被永久移动到其他位置，响应会带一个`Location` 头部，是移动后的url；

   302临时重定向，也会带一个`Location`头部；

   304资源未更新，通知浏览器可以使用缓存的内容，请求会带有`If-None-Match`和`If-Modified-Since`；

6. 直接访问服务器，Referer字段是什么？

   在浏览器直接输入地址、或者用浏览器书签访问页面，是不会带Referer头部的，在一个网页点击链接，请求会带上该页面的url，加载静态资源也会带上Referer

7. transition和animation哪一个性能好？

   因为都是css的动画，区别应该不大，但它们也有区别，transition关注开始和结束状态，animation可以定义很多中间态关键帧。

8. v-model的原理

   它其实就是转换成数据绑定和监听事件

9. hash和history的区别

   是否带#，hash是监听hashchange事件从而改变前端路由，history是利用History接口的pushState和replaceState，这两个方法可改变history对象的url却不会刷新页面发请求。

10. 给定一个字符串，输出该字符串所有排列的可能？

    ```javascript
    function fn(s) {
      const visited = new Array(s.length).fill(false);
    
      const res = [];
      const recur = (pos, curStr) => {
        if (pos === s.length) {
          res.push(curStr);
          return;
        }
        for (let i = 0; i < s.length; i++) {
          if (!visited[i]) {
            visited[i] = true;
            recur(pos + 1, curStr + s.charAt(i));
            visited[i] = false;
          }
        }
      };
      recur(0, "");
      return res;
    }
    console.log(fn("abc"));
    ```

11. 获取页面所有节点数？

    ```javascript
    document.querySelectorAll('*').length
    ```

12. 给定入栈和出栈的两个序列，判断这个出入栈规则是否正确？

    ```javascript
    /**
     * @param {number[]} pushed
     * @param {number[]} popped
     * @return {boolean}
     */
    var validateStackSequences = function(pushed, popped) {
        const stack = [];
        let popIdx = 0;
        let pushIdx = 0;
        stack.push(pushed[pushIdx++]);
        while (stack.length !== 0 || pushIdx !== pushed.length) {
            if (stack[stack.length - 1] === popped[popIdx]) {
                stack.pop();
                popIdx += 1;
            } else {
                if (pushIdx === pushed.length) {
                    return false;
                }
                stack.push(pushed[pushIdx++]);
            }
            
        }
        return true;
    };
    ```

13. 同源页面之间怎么通信？

    改变LocalStorage时，会触发window的storage事件，可以监听这个事件，进行后续响应。

14. 不同源页面之间怎么通信？

    `otherWindow.postMessage()`，otherWindow是其它页面的引用，如果希望限制同源，可以加targetOrigin参数，此时协议、主机、端口相同，才会发送。

15. 如何统计页面的浏览时长？

    - 页面的进入、离开，可以用window.onload和window,onbeforeunload；
    - 页面前进后退可以用pageshow和pagehide；
    - SPA可以监听路由，hash和history；
    - 最小化和切换 tab可以使用Page Visibility API，每次都会触发visibilitychange事件；

16. 写一个sleep函数

    就是返promise，开定时器，使用的时候`await sleep()`

17. http和websocket的联系

    它们都是应用层协议，都基于TCP，但websocket可以让服务器主动推送消息到浏览器

18. 什么是合成层

    合成层就是渲染层的合并，每个DOM元素都有渲染层，在每个渲染层完成单个DOM的绘制后，将会按照合理的顺序将渲染层合并，这就是合成层。[这里](https://www.kancloud.cn/surahe/front-end-notebook/944479)

19. 了解puppeteer吗？

    听过，是一个Node库，可以生成pdf

20. 写一个倒计时，剩余x天x时x分x秒，有截止日期

    关键就在根据时间戳拿到天数、小时数、分钟数和秒数

    ```javascript
    function computeLeftTime(endTime) {
      function addZero(val) {
        if (val < 10) {
          return "0" + val;
        }
        return val;
      }
      const curTime = new Date().getTime();
      const minusTime = parseInt((endTime - curTime) / 1000);
      const day = parseInt(minusTime / (60 * 60 * 24));
      const hour = parseInt((minusTime / (60 * 60)) % 24);
      const minute = parseInt((minusTime / 60) % 60);
      const second = parseInt(minusTime % 60);
    
      return `剩余${addZero(day)}天${addZero(hour)}小时${addZero(minute)}分${addZero(second)}秒`;
    }
    const endTime = new Date("2023-05-26 23:59:59");
    const display = document.querySelector(".display");
    setInterval(() => {
      display.innerHTML = computeLeftTime(endTime.getTime());
    }, 1000);
    ```

21. webpack 分包具体怎么做？

    [这里](https://www.cnblogs.com/kwzm/p/10315080.html)

    配置`optimization.splitChunks`，它最大的作用就是提取公共代码。简单点讲就是，加入有两个入口A和B，A和B都引入了模块C，那么分包就是要把C模块提出来打成bundle，这样就不会出现A bundle和B budle都包含C模块的情况，chunks规定了分包的细节。

    - chunks，如果设置为`all`，且A和B都引入了React（不管是同步引入还是异步引入），React就会被提出来单独打成bundle；如果设置为initial，那么如果React在A是同步引入，在B是异步引入，那么React就会被打成两个bundle，一个用于A，一个用于B异步加载；如果设置为async，那就只有大家都引入了的异步模块会被提出来。

    - cacheGroups，核心配置，缓存组，是可以缓存的，它实际就是分组条件，满足条件就分一个组，splitChunks就是利用这个cacheGroups来拆分模块的，看看下面的配置，之所以能把第三方库React拆出来，就是因为cacheGroups里有vendors组，它只筛选从node_modules引入的模块打进vendors缓存组。

      ```json
      cacheGroups: {
        vendors: {
          test: /[\\/]node_modules[\\/]/,
      		priority: -10
        },
        default: {
          minChunks: 2,		// 被引入超过两次就打进default组里
          priority: -20,
          reuseExistingChunk: true
        }
      }
      ```


### 面经15

1. 一个容器高800px内有三个div，第二个盒子高500px，如何让第一、三个盒子自适应高度？

   容器flex，第一、三个盒子用`flex: 1 1 0`

2. 为什么很少用table？

   - table比div更占空间
   - 非表格的元素用table语义化不好
   - table必须等待页面加载完毕才能显示出来，否则一片空白

3. Iterator接口是什么？

   想要让一个对象是可迭代的，就必须为它实现Iterator接口，为其添加`[Symbol.iterator]`方法即可

4. 计算器，计算`4 + 5 - 7 * 2`？

   用栈保存操作数，遇到+号直接推入符号后的数字，遇到-号推符号后数字的相反数，遇到乘除取栈顶元素计算后再推入

   ```javascript
   /**
    * @param {string} s
    * @return {number}
    */
   var calculate = function(s) {
     s = s.trim();
     const stack = [];
     let pre = "+";
     let num = 0;
     for (let i = 0; i < s.length; i++) {
       if (!isNaN(Number(s.charAt(i))) && s.charAt(i) !== " ") {
         num = num * 10 + Number(s.charAt(i));
       }
       if (isNaN(Number(s.charAt(i))) || i === s.length - 1) {
         switch (pre) {
           case "+":
             stack.push(num);
             break;
           case "-":
             stack.push(-num);
             break;
           case "*":
             stack.push(stack.pop() * num);
             break;
           case "/":
             const val = stack.pop() / num;
             val > 0 ? stack.push(Math.floor(val)) : stack.push(Math.ceil(val));
             break;
         }
         pre = s.charAt(i);
         num = 0;
       }
     }
     let res = 0;
     while (stack.length) {
       res += stack.pop();
     }
     return res;
   };
   ```

5. 输出题

   ```javascript
   let a = { n: 1 };
   let b = a;
   a.x = a = { n: 2 };
   console.log(a.x);
   console.log(b.x);
   
   // undefined, {n: 2}
   ```


## 拼多多

### 面经1

1. `flex: 0 1 auto `代表什么?

   有多余空间也不扩张、容器宽度不够可压缩、实际宽度跟着元素内容走。

2. less的&是什么意思？

   它就代表父元素。

3. interface和type的区别？

   - 语法不一样，type用=，interface不用=
   - type可以描述任何类型的组合，interface只能描述对象结构
   - 同名interface声明会被合并，type不允许同名声明

4. 详细介绍一下`getDerivedStateFromProps`?

   如果定义了`static getDerivedStateFromProps`，那么React将会在每一次渲染之前调用它，不论是初次挂载还是后续的更新，这个方法用于组件的state依赖于props的情况，它的两个参数分别是`props`（用于下一次渲染的props）和`state`（当前state），所以想要正确运用这个方法，需要在`state`中维护`props`的上一个状态。它返回一个object用于更新state，或者返回null不做任何操作。

   因为这个方法在每次渲染前都会调用，因此需要在里面判断一下props是否变了。

   示例：

   ```javascript
   class Form extends Component {
     state = {
       email: this.props.defaultEmail,
       prevUserID: this.props.userID
     };
   
     static getDerivedStateFromProps(props, state) {
       // Any time the current user changes,
       // Reset any parts of state that are tied to that user.
       // In this simple example, that's just the email.
       if (props.userID !== state.prevUserID) {
         return {
           prevUserID: props.userID,
           email: props.defaultEmail
         };
       }
       return null;
     }
   
     // ...
   }
   ```

5. webpack如何实现动态加载？

   一个组件既被同步引入，又被异步引入

   看[这里](https://segmentfault.com/a/1190000042093955)

   - 异步组件，es6的`import()`就是异步组件，可以在webpack打包的时候单独将它抽出来打成bundle，执行到它的时候再请求这个bundle。
   - 路由懒加载，配置路由的时候component写成函数`import()`形式，并标注webpack专用的注释`/* webpackChunkName: "about" */`。

6. React有无动态加载的API？

   `React.lazy(() => import('./about'))`

7. `React.lazy()`的原理？

   它需要传入一个返回`Promise`或`thenable`对象作为参数，lazy会返回这个异步组件。

8. webpack能动态加载require引入的模块吗？

   不能，require是同步加载组件，并且它是运行时引入。

9. require引入的模块能做Tree-Shaking吗？

   不可以，它是运行时引入，不能做静态分析。

10. 设计一个input组件需要哪些属性，value是什么数据类型？

     `value`表示输入框中的值，是`string`类型的。

11. 删掉a标签的默认样式？

    ```css
    a {
      text-decoration: none;
    }
    ```

12. require引入有什么性能问题？

    require在运行阶段才执行引入，这需要查找模块，并且还需要创建副本，会影响性能；

    而import在编译阶段就可以确定模块关系，最重要的是import可以直接导出变量，不用像require引入的对象那样层层获取变量，这又会影响性能。

13. class组件与函数组件的区别？

    - 有无生命周期
    - class有自己状态，函数组件用useState
    - 是否需要继承React.Component
    - class组件会有props的变化造成的混乱问题

14. css优先级

    !important > 内联 > id选择器 > 类选择器 > 标签选择器

    如果是多个选择器，就要使用**特指度**了。

15. 避免css全局污染有什么方法，它们的原理分别是什么？

    - scoped，它是vue-loader支持的方案，通过给元素加上data-xxx属性，同时在选择器后面加[data-xxx]让选择器仅能选择到该元素；

    - css-modules，它是css-loader支持的方案，是直接把class名编译成hash值，像下面这样写title就会变成hash值，但要记得loader有拼上modules参数表示打开css-modules，vue的话可以直接在style标签上加modules

      ```javascript
      import React from 'react';
      import style from './App.css';
      
      export default () => {
        return (
          <h1 className={style.title}>
            Hello World
          </h1>
        );
      };
      ```

      ```css
      // App.css
      .title {
        color: red;
      }
      ```

      ```javascript
      {
        test: /\.css$/,
        loader: "style-loader!css-loader?modules"
      },
      ```

16. 组件如何按需加载？

    用`import {} from '...'`引入需要的组件

17. change事件和input的事件的区别？

    在input中输入，每输入一次就会触发一次input事件，输入完成，让input失去焦点，就会触发change事件

18. change事件规定value的类型？

    ```vue
    // .lazy就是当触发change事件时才更新content，.number是控制content的类型
    <input type="text" v-model.lazy.number="content">
    ```

19. 用Promise封装请求重试，可设置重试次数和超时时间

    ```javascript
    function reTry(url, timeout, maxCount) {
      return new Promise((resolve, reject) => {
        const request = () => {
          Promise.race([
            fetch(url),
            new Promise((resolve, reject) => setTimeout(() => reject(), timeout)),
          ])
            .then((res) => {
              resolve(res);
            })
            .catch(() => {
              maxCount--;
              if (maxCount > 0) {
                request();
              } else {
                reject("maxCount");
              }
            });
        };
        request();
      });
    }
    
    reTry(11, 2000, 3)
      .then((res) => {
        console.log(res);
      })
      .catch((e) => {
        console.log(e);
      });
    ```

### 面经2

1. css和js加载，是同步还是异步？

   - js加载，就是script标签，它默认是同步加载的，会阻塞DOM树构建，除非加上defer或async；
   - css加载，可以是style标签，也可以是link标签，css加载会阻塞DOM树的渲染，但不阻塞DOM树的构建，并且会阻塞其后方的js运行。

2. 浏览器缓存位置？js缓存在哪里？

   浏览器缓存位置分内存缓存和硬盘缓存，js、图片缓存到内存，css缓存到硬盘中。

3. 实现一个父元素里两个子元素，父元素宽度固定，子元素铺满父元素？

   `flex: 1 1 0; height: 100%`

4. 对象数组转树形结构？

   ```javascript
   const list = [
     { id: 3, name: "c", parentId: 1 },
     { id: 6, name: "f", parentId: 3 },
     { id: 0, name: "root", parentId: null },
     { id: 1, name: "a", parentId: 0 },
     { id: 8, name: "h", parentId: 4 },
     { id: 4, name: "d", parentId: 1 },
     { id: 2, name: "b", parentId: 0 },
     { id: 5, name: "e", parentId: 2 },
     { id: 7, name: "g", parentId: 2 },
     { id: 9, name: "i", parentId: 5 },
   ];
   
   function list2Tree(list, root) {
     const map = new Map();
     for (let e of list) {
       const { id } = e;
       map.set(id, e);
     }
   
     for (let e of list) {
       const { parentId } = e;
       if (parentId !== null) {
         const parent = map.get(parentId);
         if (!parent.chilren) {
           parent.chilren = [];
         }
         parent.chilren.push(e);
       }
     }
     return map.get(root);
   }
   ```

5. React实现输入控件，控制台打印用户的实时输入

   ```react
   import { memo, useState } from "react";
   
   export default memo(function Child() {
     const [curVal, setCurVal] = useState("");
   
     const handleInput = (e) => {
       setCurVal(e.target.value);
       console.log(curVal);
     };
   
     return (
       <div>
         <input onInput={handleInput} value={curVal} />
       </div>
     );
   });
   ```

6. React生命周期函数？

   挂载阶段：

   `constructor`, `getDerivedStateFromProps`,`render`, `componentDidMount`

   更新阶段：

   `getDerivedStateFromProps`, `shouldComponentUpdate`, `render`, `getSnapshotBeforeUpdate`, `componentDidUpdate`

   卸载阶段：

   `componentWillUnmount`

7. 对正则表达式的理解？可以做什么？`\w`表示什么？

   正则表达式定义方式可以用`/^abc/`，也可以用`new RegExp('^abc')`，方法有`exec`和`test`；

   `string`类型可直接使用`match`、`matchAll`、`replace`方法

   用于匹配字符串中符合这个pattern的字符，在字符串替换中很有用。

   `\w`表示匹配任意单字符：A-Z a-z 0-9

8. merge、rebase、cherry-pick的区别？

   merge是把两个分支合并，生成新的提交记录；rebase是找到两个分支的公共提交，从此处截断应用到另一个分支；cherry-pick是直接把指定的提交移到某个分支后面，比如有两个分支，把新代码提交到其中一个分支后，用cherry-pick把这条记录复制到另一个分支上。

9. `git push -f`后怎么恢复？

   查reflog，reset回去再重新push

10. 为Array对象添加一个取出重复项的方法`Array.prototype.unique()`？

   ```javascript
   Array.prototype.unique = function () {
     if (this === Array.prototype) {
       throw new Error("err");
     }
   
     const res = [];
     const set = new Set();
     this.forEach((e) => {
       if (set.has(e)) {
         if (res.indexOf(e) === -1) {
           res.push(e);
         }
       } else {
         set.add(e);
       }
     });
     return res;
   };
   
   console.log([1, 1, 2, 3, 4, 5, 5, 5].unique());
   ```

11. 认证、授权、鉴权、`权限控制的区别`、关系？

    认证是指根据用户持有的信息，确认其身份；

    授权是指获取用户的委派权限；

    鉴权是指解析授权媒介，验证其真实性；

    权限控制：将操作配置为权限列表，若用户的操作在其权限内，则允许操作；

12. `xhr.readyState`几个数字的含义？

    - 0 初始状态
    - 1 open方法被调用
    - 2 接收到response header
    - 3 响应正在被加载
    - 4 请求完成

13. 如何让p标签具有编辑功能？

    ```html
    <p contenteditable="true">
      hello
    </p>
    ```

14. 排序算法的稳定性？

    不稳定：

    - 堆
    - 希尔
    - 快排
    - 选择

    稳定：

    - 插入
    - 冒泡
    - 归并
    - 基排

15. get和post区别

    - get必须遵循幂等性，就是说一个请求如果不符合幂等性，就不能用get
    - （*）GET请求的参数被包含在URL里面，并且请求参数会被完整地保留在浏览器记录中，由于这些参数直接暴露在URL中，可能会存在安全问题，所以GET请求一般只被用来获取资源。而POST请求的参数放在请求主体（entity body）中，并且参数不会被保留，相比起来，POST更安全。
    - GET请求 中的参数只支持URL编码，POST请求支持多种格式编码。
    - GET请求只支持ASCII字符格式的参数，而POST没有限制。
    - （*）GET请求提交的数据有大小限制，POST方法没有限制。

16. 置换元素和非置换元素区别？

    置换元素如img、input、iframe，根据元素属性来决定展示什么。

    非置换元素如span，传什么就展示什么。

17. 可继承元素和不可继承元素？

    display不可继承，font-size可继承

18. 301，302

    响应中会带location

### 面经3

1. setTimeout实现setInterval

   ```javascript
   function mySetInterval(fn, time) {
     const interval = async () => {
       await new Promise((resolve, reject) => {
         setTimeout(() => {
           fn();
           resolve();
         }, time);
       });
       interval();
     };
     interval();
   }
   
   mySetInterval(() => {
     console.log("hi");
   }, 1000);
   ```

2. 三栏实现

   三个元素，前两个分别左浮动和右浮动，第三个加overflow形成BFC

3. 左右各一个布局？

   `justify-content: space-between`

4. 当有多个context时，react组件如何选择？

   先创建全局对象`const ThemeContext = createContext()`，然后Provider，最后在要使用全局变量的地方用`useContext(ThemeContext)`拿到这个全局对象当前的值

5. useMemo有什么用？

   比如父组件给子组件传值multi，这个multi是经过非常复杂的计算得来的，那如果父组件另外一个状态（multi不依赖它）的改变导致父重渲染，那么这个multi就会被重新计算一次，造成性能损耗，可以直接用useMemo把muti的计算函数包起来，并标好依赖，那每次重渲染都会直接取multi的缓存，除非multi的依赖改变，就会重新计算。

6. useCallback有什么用？

   同理，父组件传函数给子组件，每次父组件重渲染，都会重新创建新的函数传给子组件，这样就会引起子组件也重渲染（用memo包了也没用），所以可以把这个函数用useCallback缓存起来，那么重渲染也不会创建新的函数，除非其依赖改变。

7. 手写发布订阅模式

   ```javascript
   let data = {
     name: "fan",
     age: 22,
   };
   
   let activeFn;
   
   function effect(fn) {
     activeFn = fn;
     fn();
   }
   
   const bucket = new WeakMap();
   
   function track(target, key) {
     if (!activeFn) {
       return;
     }
     let depsMap = bucket.get(target);
     if (!depsMap) {
       bucket.set(target, (depsMap = new Map()));
     }
     let deps = depsMap.get(key);
     if (!deps) {
       depsMap.set(key, (deps = new Set()));
     }
     deps.add(fn);
     activeFn = null;
   }
   
   function trigger(target, key) {
     const depsMap = bucket.get(target);
     if (!depsMap) {
       return;
     }
     const deps = depsMap.get(key);
     if (!deps) {
       return;
     }
     deps.forEach((fn) => {
       fn();
     });
   }
   
   const p = new Proxy(data, {
     get(target, key, receiver) {
       track(target, key);
       return Reflect.get(target, key, receiver);
     },
     set(target, key, val, receiver) {
       const isSuccess = Reflect.set(target, key, val, receiver);
       trigger(target, key);
       return isSuccess;
     },
   });
   
   let a = 1;
   
   const fn = () => {
     a = p.name;
   };
   
   effect(fn);
   
   console.log(a);
   p.name = "gggg";
   console.log(a);
   
   ```

8. Vue-router路由模式

   hash、history

9. vuex数据流

<img src="/Users/erfan/Library/Application Support/typora-user-images/截屏2023-05-31 00.59.48.png" alt="截屏2023-05-31 00.59.48" style="zoom: 33%;" />

10. 将url转换为key和value对象，考虑“+”、中文等特殊字符。

    利用`encodeURICompoent`和`decodeURIComponent`转换特殊字符，特殊字符一般用多个%xx来表示

11. babel转换的原理？

    - 解析，通过解析器进行词法分析和语法分析，把源码转换成AST抽象语法树；

    - 转换，操作AST，可以增删，转换成想要的样子
    - 代码生成，深度遍历第2步的抽象语法树生成新的代码

12. 词法分析和语法分析分别做了什么？

    词法分析就是将源代码按字符读取，按照预定的规则合并成一个个token，将整个代码分割成一个token列表；

    ```json
    // const a = 'hello world';
    [
        {
            "type": "Keyword",
            "value": "const"
        },
        {
            "type": "Identifier",
            "value": "a"
        },
        {
            "type": "Punctuator",
            "value": "="
        },
        {
            "type": "String",
            "value": "'hello world'"
        }
    ]
    ```

    语法分析（也叫解析）就是将tokens列表转换成树结构。

    ```json
    {
      "type": "Program",
      "body": [
        {
          "type": "VariableDeclaration",
          "declarations": [
            {
              "type": "VariableDeclarator",
              "id": {
                "type": "Identifier",
                "name": "a"
              },
              "init": {
                "type": "Literal",
                "value": "hello world",
                "raw": "'hello world'"
              }
            }
          ],
          "kind": "const"
        }
      ],
      "sourceType": "script"
    }
    ```

13. vue父子组件生命周期执行顺序

    挂载阶段父执行beforeMount后就开始执行子beforeCreate

    更新阶段父执行到beforeUpdate，再开始子

    卸载阶段父执行到beforeUnmount，再开始子

14. keepAlive原理

    缓存组件状态

15. 组件通信方式？

    props、emit、expose/ref、v-model、attrs、proivde/inject、vuex、mitt

16. 为什么要有mutation和action？

    因为必须要保证mutation是同步的，因此异步代码就需要放在action中；devtools会记录mutation前和后的两个快照，如果mutation中对state的改变是异步的，那么会引起调试困难，devtools也不能正确记录两个快照。

17. eventBus的原理？

    基于发布订阅模式

18. computed和watch的区别？

    computed可以缓存，computed中不能有异步操作

    watch用于监听的值变化后要做的操作。

19. vue是怎么监听数组方法的？也就是说调用数组方法后，为什么感知到数组的变化？

    vue2重写了数组的方法，在执行方法的时候会通知所有用到数组的地方，发布订阅模式

    vue3的Proxy，对数组元素的操作都会触发get或set，也就是在此时来通知。

20. 实现vue监听数组？

21. 配置loader时同一数组中loader的执行顺序？

    从右往左，先执行less-loader

    ```json
    {
    	use: ['style-loader', 'css-loader', 'less-loader']
    }
    ```

22. typescript特点？和js比有什么优势？

    - js采用动态类型，运行的时候才确定变量的类型；ts采用静态类型，声明时确定类型；
    - js是弱类型语言，一个变量可赋予不同类型的值；ts是强类型，一个变量被指定数据类型后，如果不强制转换，就一直是这个类型；
    - ts总是需要编译成js再运行

    ts的优势：引入静态类型声明，减少不必要的类型判断和注释；及早发现问题；更易维护

23. pureComponent有什么用？

    通常，React父组件重渲染就会引起子组件重渲染，即使子组件props没有变化。

    除了用memo包函数组件可以实现不重渲染子组件外，还可以用`pureComponent`，它实际是为组件写了一个shouldComponentUpdate，允许在props未变的情况下，不要重渲染子组件。

24. 什么是纯函数，有什么特点？

    - 不会对外部产生副作用
    - 相同的输入，会有相同的输出

25. 什么是高阶函数HOC？

    高阶函数允许传入一个组件，返回一个新的组件，高阶函数的作用是代码复用

    ```react
    import { Component } from 'react';
    
    const HighOrderComponent = (WrappedComponent) =>
      class extends Component {
        render() {
          return <WrapperdComponent {...this.props} />;
        }
      };
    ```

26. vue中可以用mobx吗？

    vue本身就是响应式的，mobx就是一套响应式系统，mobx一般和react结合起来，实现用react写vue的感觉，所以，vue不需要再引入其它响应式系统了。

27. 用迭代解链表反转？

    ```javascript
    var reverseList = function(head) {
        let cur = head;
        let pre = null;
        while (cur !== null) {
            const next = cur.next;
            cur.next = pre;
            pre = cur;
            cur = next;
        }
        return pre;
    };
    ```

28. 股票1

    ```javascript
    var maxProfit = function(prices) {
        let max = 0;
        let curMinPrice = Infinity;
        for (let i = 0; i < prices.length; i++) {
            if (prices[i] < curMinPrice) {
                curMinPrice = prices[i];
            }
            if (prices[i] - curMinPrice > max) {
                max = prices[i] - curMinPrice;
            }
        }
        return max;
    };
    ```

29. 股票2

    ```javascript
    var maxProfit = function(prices) {
        const dp = new Array(2);
        dp[0] = 0;
        dp[1] = -prices[0];
        let cur0;
        let cur1;
        for (let i = 1; i < prices.length; i++) {
            cur0 = Math.max(dp[0], dp[1] + prices[i]);
            cur1 = Math.max(dp[0] - prices[i], dp[1]);
            dp[0] = cur0;
            dp[1] = cur1;
        }
        return dp[0];
    };
    ```

30. session和cookie的区别？

    - cookie存储在客户端，session存储在服务端
    - cookie只能是ASCII
    - cookie易被窃取，session相对安全
    - cookie不超过4K

31. cookie+sessionId的模式有什么缺点？怎么解决？

    如果服务器有多台，session就需要共享，过多的session也需要大量存储空间。

    - 写入持久层，但这种方式工作量大，并且持久层如果挂了就完了

    - 服务端索性不保存session了，所有数据都以JWT形式保存在客户端，每个请求都带上

32. 如果客户端禁用了cookie怎么识别身份？

    - 在url中拼接sessionId
    - JWT（Json Web Token），服务器生成json来表示当前交互状态，加密、签名后发给客户端保存，每次请求都带上，这个JWT分为header、payload、signature

33. 单链表对折

    ```javascript
    var reorderList = function(head) {
        const getMidNode = () => {
            let slow = head;
            let fast = head;
            while (slow.next !== null && fast.next !== null) {
                slow = slow.next;
                fast = fast.next;
                if (fast.next !== null) {
                    fast = fast.next;
                }
            }
            return slow;
        };
        const reverseList = (p) => {
            let pre = null;
            let next;
            while (p !== null) {
                next = p.next;
                p.next = pre;
                pre = p;
                p = next;
            }
            return pre;
        };
        const mergeList = (p, q, mid) => {
            while (p !== mid && q !== mid) {
                let pTemp = p.next;
                let qTemp = q.next;
    
                p.next = q;
                q.next = pTemp;
                
                p = pTemp;
                q = qTemp;
            }
        }
        const midNode = getMidNode();
        const q = reverseList(midNode);
        mergeList(head, q, midNode);
        return head;
    };
    ```

34. ts中下面两种写法有什么区别？

    ```typescript
    function say(p: string | undefined) {
      console.log(p);
    }
    
    function say(p?: string) {
      console.log(p);
    }
    ```

    `p: string | undefined`且不加问号，那么表示，可以传string，也可以传undefined，但这个参数一定要传；

    `p?: string`表示这个参数要么传string，要么不传；

35. IE盒模型和W3C盒模型有什么区别？怎么使用IE盒模型？

    IE盒模型width和height包括content、padding、border；

    标准的盒模型是只有content区域；

    想要使用IE盒模型，设置box-sizing: border-box即可

36. jsbridge实现原理？

    安卓定义JsBridge类，在类中定义实例方法`call`（该方法可被js调用）和`register`方法（用于把客户端定义的方法转成Map便于查询）；利用`webview`的接口`addJavascriptInterface`将JsBridge实例注入到`window`上，并起好名字`_jsbridge`，这样js就可以利用`window._jsbridge`拿到这个JsBridge实例，进而调用`call`来执行安卓上的方法。

    在js端，需要写一个`callNative`方法，该方法是调用客户端接口的统一方法，在里面会处理args、在全局注册回调函数，最后调用`call`。客户端执行完方法后就会利用executeJavaScript接口执行绑在window上的回调函数，进而把一些结果传回到js。

    ```javascript
    window.callbackId = 0;
    
    function callNative(method, arg, cb) {
      let args = {
        data: arg === undefined ? null : JSON.stringify(arg)
      };
    
      if (typeof cb === 'function') {
        const cbName = 'CALLBACK' + window.callbackId++;
        window[cbName] = cb;
        args['cbName'] = cbName;
      }
    
      if (window._jsbridge) {
        window._jsbridge.call(method, JSON.stringify(args));
      }
    }
    ```

37. Reflection的作用？

    它提供了一套标准的反射能力，参数和返回值都是统一的风格，可以写出更优雅的代码；

    ```javascript
    // 要想获取一个对象的所有属性，以前只能这样
    Object.getOwnPropertyNames(obj).concat(Objcet.getOwnPropertySymbol(obj));
    // 有了反射之后
    Reflect.ownKeys(obj);
    
    // 以前定义属性
    try {
      Object.defineProperty(obj, key, attr);
    } catch {
    	// ...
    }
    // 有了Reflect，就不需要try catch了
    if (Reflect.defineProperty()) {
      
    } else {
      
    }
    ```

    







