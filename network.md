### 1. 常见状态码

#### 1xx 请求已被接受，需要继续处理

100 服务器通知客户端已经收到请求，要求客户端继续发送请求，如果客户端请求已经发送完，就忽略这个响应，服务器需要发送一个最终响应；

101 服务器根据客户端的请求切换协议

#### 2xx 请求已被服务器接收、理解

200 成功

201 请求成功，服务器创建了新的资源

202 服务器已接受请求，但尚未处理

203 服务器已成功处理请求，但返回的信息可能来自另一来源

204 服务器成功处理请求，但没有返回任何内容

#### 3xx 要完成请求，需要进一步操作

300（多种选择）针对请求，服务器可执行多种操作，服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择

**301（重定向，永久移动）**请求的内容已永久移动到新位置，对get或者head请求的响应，会自动将请求者转到新的位置。

**302（重定向，临时移动）**目标资源临时移动到了另一个 URI 上，由于重定向是临时发生的，所以客户端在之后的请求中还应该使用原本的 URI。

303 （查看其它位置）表示服务器要将浏览器重定向到另一个资源，这个资源的 URI 会被写在响应 Header 的 Location 字段

**304 （资源未更新）**提示客户端请求的资源未修改过，意味着可使用上一次的缓存

305（使用代理）请求者只能使用代理访问所请求的网页

307（临时重定向）307 的定义实际上和 302 是一致的，唯一的区别在于，307 状态码不允许浏览器将原本为 POST 的请求重定向到 GET 请求上。

#### 4xx 客户端请求发生错误

400（错误请求）服务器不理解请求的语法

**401（未授权）**请求需要身份验证，一般见于需要登录的资源

403（禁止）服务器拒绝请求

**404（未找到）**服务器没找到请求的资源

405（方法禁用） 禁用请求中指定的方法

408（请求超时） 服务器等候请求时发生超时

#### 5xx 服务器发生错误、异常

500（服务器内部错误）服务器错误

501（尚未实施） 服务器不具备完成请求的功能

502（错误网关） 服务器作为网关或代理，从上游服务器收到无效响应

503（服务不可用） 服务器目前无法使用（由于超载或停机维护）

504（网关超时） 服务器作为网关或代理，但是没有及时从上游服务器收到请求

505（HTTP 版本不受支持） 服务器不支持请求中所用的 HTTP 协议版本

### 2. 强缓存和协商缓存的区别

1. ​	如果浏览器命中强缓存，则不需要给服务器发请求，直接去缓存；如果浏览器命中协商缓存，则由服务器决定是否使用缓存，会发生客户端和服务器的一次通信；
2. 在Chrome中，使用强缓存的状态码是200（from cache）（虽然未发请求），而如果走协商缓存，状态码是304（not modified）；

### 3. 浏览器使用缓存的流程

![image.png](https://segmentfault.com/img/remote/1460000021661659)

每一次http请求，都会先判断一下是否能用缓存；

第一次请求后，浏览器缓存资源，再次请求时，会走下面的步骤

1. 浏览器获取上一次请求缓存下来的header信息，根据header中的Expires和Cache-Control等字段判断是否命中强缓存；
2. 如果没有命中强缓存，就会发送请求到服务器，带上 `IF-Modified-Since`或者`IF-None-Match`等header字段，它们的值分别是第一次请求返回的`Last-Modified`或者 `Etag`，交给服务器来判断是否能够使用缓存，如果可以使用缓存则返回304，且不会返回资源，否则会返回最新的资源，并带上缓存相关header；

### 4. 什么情况下会命中协商缓存（小红书）

当浏览器中存在所请求资源的缓存，并且该缓存已过期时，就会触发协商缓存，客户端向服务器发送请求，携带`If-None-Match`或者`If-Modified-Since`，它们的值分别是`Etag`和`Last-Modified`，交给服务器判断是否使用缓存。

### 5. 如果一个文件有强缓存，服务器修改文件后，如何让客户端访问到修改后的文件（小红书）

这个问题就是如何保证发版后客户端能及时更新。

我们一般会保证让index.html不是强缓存，可以通过Cache-Control的no-cache命令，使其每一次都使用协商缓存（也必须使用协商缓存），而资源文件可以是强缓存的。我们只需要让资源文件名在更新后的hash名不一样，就可以保证浏览器能够请求新的资源文件。不过最好的方式是使用非覆盖式发布，也就是让新旧资源都能够访问到，这样不论index.html里引入的资源名是新还是旧，都不会崩掉。

### 6. Etag的计算规则

nginx 中 etag由响应头的 Last-Modified` 与 `Content-Length 表示为十六进制组合而成。

虽然它不完美，但很高效

所以Etag变了，并不意味着文件内容一定变了。

### 7. 二进制传输和文本传输的区别

比如有一段数据：name: 'fan', age: 20

文本传输是可以从传输的数据看出其含义的，会把这一整段都传输；

如果是二进制传输，首先会约定一个协议，比如前10个字节表示name，后10个字节表示年龄，此时，可以只需20个字节把'fan'和20传输过去就行。二进制传输的关键就是需要提前商定一个协议。

### 8. http/2新特性

现在浏览器对同一个域名的 TCP 连接个数有限制，一般是 6 - 8 个

#### http/1的缺陷

1. TCP连接本身的性能瓶颈，比如三次握手建立连接以及慢启动导致的传输速率低；
2. 队头阻塞，同一个tcp连接下，请求是按顺序发送的，必须收到上一个请求的响应，才能发送下一个请求，如果前面的请求花了很长时间，就会阻塞后面的；
3. 头部大且重复，每一个http/1请求都会有大量重复的header，并且header还很大，比如cookie、userAgent等；
4. 明文传输不安全，https解决了这个问题；
5. 不支持服务器推送，服务器推送就是只请求了index.html，但服务器会把index.html、main.js、index.css三个文件一起响应给客户端，http/1只能一个一个地发请求；

#### http/2的优势

1. 二进制传输，按照提前商定的协议，http/2可以把传输的信息分割为更小的帧，数据分帧后，heade+body的结构就消失了，变成了一个个“碎片”；
2. header压缩，header会通过gzip或compress压缩后再发送，并且客户端和服务器还会维持一张表，所有header字段都会存入这个表，以后就不发送同样的字段了，只发索引号；
3. 多路复用，多路复用就是一个TCP连接下可以同时发多个请求，这样就不需要等到上一个请求的响应后再发下一个请求，
4. 服务端推送，允许未经客户端请求，主动向客户端发送资源，客户端可以选择是否接收

### http/1的keep-Alive长连接和http/2的多路复用的区别

1. http/1基于本文传输，http/2基于二进制传输，可分解为独立的帧，交错发送；
2. http/1只能一个一个按顺序响应，http/2不按序响应；
3. http/1单个TCP下一次只能处理一个请求，http/2同一时刻可发送多个请求；
4. http/1为了解决队头阻塞，会把同一页面的资源分散到不同域名下，建立多个TCP连接，http/2同域名下都在单个连接上完成；

### http/2缺陷

1. 建立TCP连接时间长；

2. http/2虽然解决了应用层的队头阻塞（不需要等待上一个请求收到响应才发送下一个请求），但TCP层面的队头阻塞是无法解决的，TCP连接里如果出现丢包，会停止，等待重传丢失的TCP包，此时后续的包是完全阻塞住的，会被放在缓存区，但不会交给应用层。并且万一丢包，http2比http1.0在TCP层面的队头阻塞会更加严重，因为http2是单TCP连接，流量非常大，丢包后阻塞的更多，而http1.0下会开多个TCP连接，一个出问题还能保证其它的正常。

### 为什么http/1.x不能实现多路复用

http/1.x只允许串行发送http请求，收到上一个请求的响应后才能发送下一个请求，也就是多个请求不能重叠；

http/1.x有了管道机制之后，可以允许在一个TCP连接里并行多个http请求（不用等待上一个请求返回就可以发送下一个请求），但是由于http/1.x使用的是文本协议，服务端在应用层接收消息的时候，是以分隔符来判断的，因此，只能把一个http请求全部接收后，才能接收下一个http请求，所以虽然可以并行发请求了，但实际上还是必须按发送请求的顺序进行接收和响应；

确实可以：http/2有二进制分帧这个步骤，会把请求消息分割成帧，帧有自己的结构，服务器的应用层拿到的就是多个请求大量的帧，不过，因为每个帧都标记了它属于哪个请求，因此可以完整地把收到的帧分属到不同的请求，这样就不存在必须将一个请求全部解析完成后才能解析下一个请求的问题，一个TCP连接中，可以并行多个请求，并且可以不按发送顺序来响应，谁先解析完就先响应；



